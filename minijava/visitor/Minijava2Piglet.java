//
// Generated by JTB 1.3.2
//

package minijava.visitor;
import minijava.minijava2piglet.*;
import minijava.syntaxtree.*;
import minijava.typecheck.*;

import java.util.*;
import java.lang.Math.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class Minijava2Piglet extends GJDepthFirst<AllType,AllType> {


	//找到当前正在处理的类和方法，确定符号时使用
	private MyClass nowClass;
	private MyMethod nowMethod;
	
	//当前方法中所有局部变量的变量表
	private Hashtable<String, Integer> curTmpVarList;
	
	//当前方法中可以继续使用寄存器的下一个标号
	private int curTmpNum;
	
	//当前Piglet代码中的语句标号
	private int curLableNum = 0;
	
	//类的变量表
	private Hashtable<String, Vector<String>> varList = new Hashtable<String, Vector<String>>();
	
	//类的方法表
	private Hashtable<String, Vector<String>> methodList = new Hashtable<String, Vector<String>>();
	
	private void buildVarList(MyClass curClass) {
		MyClass orgClass = curClass;
		Vector<String> curVarList = new Vector<String>();
		Vector<MyClass> classList = new Vector<MyClass>();
		do {
			classList.add(curClass);
			curClass = curClass.getParentClass();
		}while(curClass != null);
		//先添加最祖先的变量，然后依次往后，为了之后的多态
		for(int i = classList.size() - 1; i >= 0; i--) {
			Enumeration e = classList.get(i).memberVar.keys();
			while(e.hasMoreElements()) {
				String curVarName = (String)e.nextElement();
				if(!curVarList.contains(curVarName)) {
					curVarList.add(curVarName);
				}
			}
		}
		varList.put(orgClass.getName(), curVarList);
	}
	//在类中找到该变量的存放的偏移地址
	private int findVarPos(String curClassName, String curVarName) {
		Vector<String> curVarList = varList.get(curClassName);
		for(int i = 0; i < curVarList.size(); i++)
			if(curVarList.get(i).equals(curVarName))
				return (i + 1) << 2;
		
		//Unknown error
		return -1;
	}
	
	//判断方法是否重写，即_之后的字符是否相同
	private int contains(Vector<String> list, String name) {
		for(int i = 0; i < list.size(); i++) {
			String curName = list.get(i);
			curName = curName.substring(curName.indexOf('_') + 1);
			if(curName.equals(name))
				return i;
		}
		return -1;
	}
	
	private void buildMethodList(MyClass curClass) {
		MyClass orgClass = curClass;
		Vector<String> curMethodList = new Vector<String>();
		Vector<MyClass> classList = new Vector<MyClass>();
		do {
			classList.add(curClass);
			curClass = curClass.getParentClass();
		}while(curClass != null);
		//先添加最祖先的方法，然后依次往后，为了之后的多态
		for(int i = classList.size() - 1; i >= 0; i--) {
			Enumeration e = classList.get(i).method.keys();
			while(e.hasMoreElements()) {
				String curMethodName = (String)e.nextElement();
				int x = contains(curMethodList, curMethodName);
				if(x == -1) {
					curMethodList.add(classList.get(i).getName() + "_" + curMethodName);
				}
				else {
					curMethodList.set(i, classList.get(i).getName() + "_" + curMethodName);
				}
			}
		}
		methodList.put(orgClass.getName(), curMethodList);
	}
	
	//在类中找到方法的存放的偏移地址
	private int findMethodPos(String curClassName, String curMethodName) {
		Vector<String> curMethodList = methodList.get(curClassName);
		for(int i = 0; i < curMethodList.size(); i++) {
			String curName = curMethodList.get(i);
			curName = curName.substring(curName.indexOf('_') + 1);
			if(curName.equals(curMethodName))
				return i << 2;
		}
		//Unknown error
		return -1;
	}

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public AllType visit(Goal n, AllType argu) {
      AllType _ret=null;
      /*
       * 遍历所有类并建立相应的varList和methodList（包括祖先类）
       */
      AllClasses curClasses = (AllClasses)argu;
      Enumeration e = curClasses.classes.elements();
      while(e.hasMoreElements()) {
    	  MyClass curClass = (MyClass)e.nextElement();
    	  buildVarList(curClass);
    	  buildMethodList(curClass);
      }
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public AllType visit(MainClass n, AllType argu) {
	  PrintPiglet.pMain();
	  String curClassName = n.f1.f0.toString();
	  MyClass curClass = ((AllClasses)argu).getMyClass(curClassName);
	  MyMethod curMethod = curClass.getMethod("main");
	  
	  nowClass = curClass;
	  
	  curTmpVarList = new Hashtable<String, Integer>();
	  curTmpVarList.put("this", 0);
	  int tot = 1;
	  curTmpNum = 20;
	  if(curMethod.paraName.size() < 20) {
		  for(int i = 0; i < curMethod.paraName.size(); i++) {
			  curTmpVarList.put(curMethod.paraName.get(i), tot++);
		  }
		  Enumeration e = curMethod.localVar.keys();
		  while(e.hasMoreElements()) {
			  String curVarName = (String)e.nextElement();
			  if(!curTmpVarList.containsKey(curVarName))
				  curTmpVarList.put(curVarName, curTmpNum++);
		  }
	  }
	  else {
		  for(int i = 0; i < 18; i++) {
			  curTmpVarList.put(curMethod.paraName.get(i), tot++);
		  }
		  Enumeration e = curMethod.localVar.keys();
		  while(e.hasMoreElements()) {
			  String curVarName = (String)e.nextElement();
			  if(!curTmpVarList.containsKey(curVarName))
				  curTmpVarList.put(curVarName, curTmpNum++);
		  }
	  }
	  
	  nowMethod = curMethod;
	  
      n.f15.accept(this, curMethod);
      PrintPiglet.pEndProcedure();
      return null;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public AllType visit(TypeDeclaration n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public AllType visit(ClassDeclaration n, AllType argu) {
      String curClassName = n.f1.f0.toString();
      MyClass curClass = ((AllClasses)argu).getMyClass(curClassName);
      
      nowClass = curClass;
      
      n.f4.accept(this, curClass);
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public AllType visit(ClassExtendsDeclaration n, AllType argu) {
      AllType _ret=null;
      String curClassName = n.f1.f0.toString();
      MyClass curClass = ((AllClasses)argu).getMyClass(curClassName);
      
      nowClass = curClass;
      
      n.f6.accept(this, curClass);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public AllType visit(VarDeclaration n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public AllType visit(MethodDeclaration n, AllType argu) {
	   /*
	    * TEMP寄存器分配规则为：
	    * 若参数少于20个，则0号为当前方法的地址，1-19号为参数寄存器（余下不用），20-inf为局部变量寄存器
	    * 若参数大于等于20个，则0号为当前方法的地址，1-18号为前一部分参数的寄存器，19号为剩余参数存放数组的首地址，20-inf为局部变量寄存器
	    */
	  String curMethodName = n.f2.f0.toString();
	  MyMethod curMethod = ((MyClass)argu).getMethod(curMethodName);
	  curTmpVarList = new Hashtable<String, Integer>();
	  curTmpVarList.put("this", 0);
	  int tot = 1;
	  curTmpNum = 20;
	  if(curMethod.paraName.size() < 20) {
		  for(int i = 0; i < curMethod.paraName.size(); i++) {
			  curTmpVarList.put(curMethod.paraName.get(i), tot++);
		  }
		  Enumeration e = curMethod.localVar.keys();
		  while(e.hasMoreElements()) {
			  String curVarName = (String)e.nextElement();
			  if(!curMethod.paraName.contains(curVarName))
				  curTmpVarList.put(curVarName, curTmpNum++);
		  }
	  }
	  else {
		  for(int i = 0; i < 18; i++) {
			  curTmpVarList.put(curMethod.paraName.get(i), tot++);
		  }
		  Enumeration e = curMethod.localVar.keys();
		  while(e.hasMoreElements()) {
			  String curVarName = (String)e.nextElement();
			  if(!curMethod.paraName.contains(curVarName))
				  curTmpVarList.put(curVarName, curTmpNum++);
		  }
	  }
	  
	  nowMethod = curMethod;
	  
	  PrintPiglet.pBeginProcedure(curMethod.owner.getName(), curMethod.getName(), curMethod.paraName.size() + 1);
	  PrintPiglet.pBegin();
      n.f8.accept(this, curMethod);
      PrintPiglet.pReturn();
      n.f10.accept(this, curMethod);
      PrintPiglet.println("");
      PrintPiglet.pEndProcedure();
      return null;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public AllType visit(FormalParameterList n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public AllType visit(FormalParameter n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public AllType visit(FormalParameterRest n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public AllType visit(Type n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public AllType visit(ArrayType n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public AllType visit(BooleanType n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public AllType visit(IntegerType n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public AllType visit(Statement n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public AllType visit(Block n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public AllType visit(AssignmentStatement n, AllType argu) {
	   /*
	    * 变量赋值语句，直接赋值给变量寄存器或者存放变量的内存地址
	    */
      String curVarName = n.f0.f0.toString();
      MyMethod curMethod = (MyMethod)argu;
      MyClass curClass = curMethod.owner;
      //在局部变量表且有寄存器保存他的值的时候
      if(curTmpVarList.get(curVarName) != null) {
    	  PrintPiglet.print("MOVE TEMP " + curTmpVarList.get(curVarName) + " ");
      }
      else {
    	  int offset = -1;
    	  for(int i = 18; i < curMethod.paraName.size(); i++) {
    		  if(curMethod.paraName.get(i).equals(curVarName))
    			  offset = (i - 18) << 2;
    	  }
    	  if(offset != -1) {//当前方法的参数列表超过了19个，若该变量在参数列表的第19个或之后，需要用地址加偏移找到
    		  PrintPiglet.print("HSTORE TEMP 19 " + offset + " ");
    	  }
    	  else {//在类的成员变量中，需要用地址加偏移找到
    		  PrintPiglet.print("HSTORE TEMP 0 " + findVarPos(curClass.getName(), curVarName) + " ");
    	  }
      }

      n.f2.accept(this, argu);
      PrintPiglet.println("");
      return null;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public AllType visit(ArrayAssignmentStatement n, AllType argu) {
	   /*
	    * 给数组元素赋值，首先将数组首地址取出，也就是某个寄存器或者某个内存地址（存放数组首地址的内存地址）
	    */
	  String curVarName = n.f0.f0.toString();
	  MyMethod curMethod = (MyMethod)argu;
	  MyClass curClass = curMethod.owner;
	  int t1 = curTmpNum++; //数组首地址寄存器t1
	  //在局部变量表且有寄存器保存他的值的时候
	  if(curTmpVarList.get(curVarName) != null) {
		  PrintPiglet.println("MOVE TEMP " + t1 + " TEMP " + curTmpVarList.get(curVarName));
	  }
	  //在类的成员变量中，需要用地址加偏移找到
	  else {
		  int offset = -1;
		  for(int i = 18; i < curMethod.paraName.size(); i++) {
	   	  if(curMethod.paraName.get(i).equals(curVarName))
	   		  offset = (i - 18) << 2;
		  }
		  if(offset != -1) {//当前方法的参数列表超过了19个，若该变量在参数列表的第19个或之后，需要用地址加偏移找到
			  PrintPiglet.println("HLOAD TEMP " + t1 + " TEMP 19 " + offset);
		  }
		  else { //否则在类的成员变量中，需要用地址加偏移找到
			  PrintPiglet.println("HLOAD TEMP " + t1 + " TEMP 0 "+ findVarPos(curClass.getName(), curVarName));
		  }
	  }
	  
	  //t1保存数组首地址，t2先是下标索引，然后计算地址，最后取出来值返回
	  /*
	   * MOVE TEMP t2 EXP1
	   * MOVE TEMP t2 PLUS TEMP t1 TIMES PLUS TEMP t2 1 4
	   * HSTORE TEMP t2 0 EXP2
	   */
	  int t2 = curTmpNum++; //保存返回表达式的值，作数组下标索引
	  PrintPiglet.print("MOVE TEMP " + t2 + " ");
      n.f2.accept(this, argu);
      PrintPiglet.println("");
      //现在计算 TEMP t2 = TEMP t1 + (TEMP t2 + 1) * 4
      //MOVE TEMP t2 PLUS TEMP t2 TIMES 4 PLUS 1 TEMP t2
      PrintPiglet.println("MOVE TEMP " + t2 + " PLUS TEMP " + t1 + " TIMES PLUS TEMP " + t2 + " 1  4");
      PrintPiglet.print("HSTORE TEMP " + t2 + " 0 ");
      n.f5.accept(this, argu);
      PrintPiglet.println("");
      return null;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public AllType visit(IfStatement n, AllType argu) {
	  /*
	   * CJUMP EXP L1
	   * STMT...
	   * JUMP L2
	   * L1 STMT...
	   * L2 NOOP
	   */
	  int L1 = curLableNum++, L2 = curLableNum++;
	  PrintPiglet.print("CJUMP ");
      n.f2.accept(this, argu);
      PrintPiglet.println(" L" + L1);
      n.f4.accept(this, argu);
      PrintPiglet.println("JUMP L" + L2);
      PrintPiglet.println("L" + L1);
      n.f6.accept(this, argu);
      PrintPiglet.println("L" + L2 + " NOOP");
      return null;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public AllType visit(WhileStatement n, AllType argu) {
	   /*
	    * L1 CJUMP EXP L2
	    * 	STMT...
	    * 	JUMP L1
	    * L2 NOOP
	    */
	  int L1 = curLableNum++, L2 = curLableNum++;
	  PrintPiglet.print("L" + L1 + " CJUMP ");
      n.f2.accept(this, argu);
      PrintPiglet.println(" L" + L2);
      n.f4.accept(this, argu);
      PrintPiglet.println("JUMP L" + L1);
      PrintPiglet.println("L" + L2 + " NOOP");
      return null;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public AllType visit(PrintStatement n, AllType argu) {
	  PrintPiglet.print("PRINT ");
      n.f2.accept(this, argu);
	  PrintPiglet.println("");
      return null;
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public AllType visit(Expression n, AllType argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(AndExpression n, AllType argu) {
	   //WARNING!!!
	   //由于不直接提供与操作，所以用 z = 1 - (x * y)，如果 z < 1，则 x && y 为真，产生副作用
	  /* BEGIN
	   * 	MOVE TEMP t1 EXP1
	   * 	MOVE TEMP t2 EXP2
	   * 	MOVE TEMP t1 MINUS 1 TIMES TEMP t1 TEMP t2
	   * 	MOVE TEMP t1 LT TEMP t1 1
	   * 	RETURN TEMP t1
	   * END
	   */
	  /*int t1 = curTmpNum++, t2 = curTmpNum++;
	  PrintPiglet.pBegin();
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
      n.f0.accept(this, argu);
      PrintPiglet.println("");
      PrintPiglet.print("MOVE TEMP " + t2 + " ");
      n.f2.accept(this, argu);
      PrintPiglet.println("");
      PrintPiglet.println("MOVE TEMP " + t1 + " MINUS 1 TIMES TEMP " + t1 + " TEMP " + t2);
      PrintPiglet.println("MOVE TEMP " + t1 + " LT TEMP " + t1 +" 1");
      PrintPiglet.pReturn();
      PrintPiglet.println("TEMP " + t1);
      PrintPiglet.pEnd();*/
	  //使用两次CJUMP实现跳转，避免副作用
	  /*  BEGIN
	   *  	MOVE TEMP t1 EXP1
	   *  	CJUMP TEMP t1 L1
	   *  	MOVE TEMP t1 EXP2
	   *  	CJUMP TEMP t1 L1
	   *  	MOVE TEMP t1 1
	   *  	JUMP L2
	   *  	L1 MOVE TEMP t1 0
	   *  	L2 NOOP
	   *  	RETURN TEMP t1
	   *  END
	   */
	  int t1 = curTmpNum++, L1 = curLableNum++, L2 = curLableNum++;
	  PrintPiglet.pBegin();
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
	  n.f0.accept(this, argu);
	  PrintPiglet.println("");
	  PrintPiglet.println("CJUMP TEMP " + t1 + " L" + L1);
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
	  n.f2.accept(this, argu);
	  PrintPiglet.println("");
	  PrintPiglet.println("CJUMP TEMP " + t1 + " L" + L1);
	  PrintPiglet.println("MOVE TEMP " + t1 + " 1");
	  PrintPiglet.println("JUMP L" + L2);
	  PrintPiglet.println("L" + L1 + " MOVE TEMP " + t1 + " 0");
	  PrintPiglet.println("L" + L2 + " NOOP");
	  PrintPiglet.pReturn();
	  PrintPiglet.println("TEMP " + t1);
	  PrintPiglet.pEnd();
	  return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(CompareExpression n, AllType argu) {
	  /*
	   * LT EXP1 EXP2
	   */
	  PrintPiglet.print("LT ");
      n.f0.accept(this, argu);
      PrintPiglet.print(" ");
      n.f2.accept(this, argu);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(PlusExpression n, AllType argu) {
	   /*
	    * PLUS EXP1 EXP2
	    */
	  PrintPiglet.print("PLUS ");
      n.f0.accept(this, argu);
      PrintPiglet.print(" ");
      n.f2.accept(this, argu);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(MinusExpression n, AllType argu) {
	   /*
	    * MINUS EXP1 EXP2
	    */
	  PrintPiglet.print("MINUS ");
      n.f0.accept(this, argu);
      PrintPiglet.print(" ");
      n.f2.accept(this, argu);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(TimesExpression n, AllType argu) {
	   /*
	    * TIMES EXP1 EXP2
	    */
	  PrintPiglet.print("TIMES ");
      n.f0.accept(this, argu);
      PrintPiglet.print(" ");
      n.f2.accept(this, argu);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public AllType visit(ArrayLookup n, AllType argu) {
	  //t1得到数组首地址，t2取出值
	  /*
	   * BEGIN
	   * 	MOVE TEMP t1 EXP1
	   * 	MOVE TEMP t2 EXP2
	   * 	MOVE TEMP t2 PLUS TEMP t1 TIMES PLUS TEMP t2 1 4
	   * 	HLOAD TEMP t2 TEMP t2 0
	   * 	RETURN TEMP t2
	   * END
	   */
	  int t1 = curTmpNum++, t2 = curTmpNum++;
	  PrintPiglet.pBegin();
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
      n.f0.accept(this, argu);
      PrintPiglet.println("");
      PrintPiglet.print("MOVE TEMP " + t2 + " ");
      n.f2.accept(this, argu);
      PrintPiglet.println("");
      PrintPiglet.println("MOVE TEMP " + t2 + " PLUS TEMP " + t1 + " TIMES PLUS TEMP " + t2 + " 1 4");
      PrintPiglet.println("HLOAD TEMP " + t2 + " TEMP " + t2 + " 0");
      PrintPiglet.pReturn();
      PrintPiglet.println("TEMP " + t2);
      PrintPiglet.pEnd();
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public AllType visit(ArrayLength n, AllType argu) {
	   //t1得到数组首地址，然后装载给t1
	   /*
	    * BEGIN
	    * 	MOVE TEMP t1 EXP
	    * 	HLOAD TEMP t1 TEMP t1 0
	    * 	RETURN TEMP t1
	    * END
	    */
	  int t1 = curTmpNum++;
	  PrintPiglet.pBegin();
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
      n.f0.accept(this, argu);
      PrintPiglet.println("");
      PrintPiglet.println("HLOAD TEMP " + t1 + " TEMP " + t1 + " 0");
      PrintPiglet.pReturn();
      PrintPiglet.println(" TEMP " + t1);
      PrintPiglet.pEnd();
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public AllType visit(MessageSend n, AllType argu) {
	   //t1为类空间的首地址，t2首先为方法组首地址，其次为具体的方法，作为返回值
	   /*
	    * CALL
	    * BEGIN
		* 	MOVE TEMP t1 EXP1
		* 	HLOAD TEMP t2 TEMP t1 0
		* 	HLOAD TEMP t2 TEMP t2 methodid
	    * RETURN TEMP t2
	    * END
	    * (TEMP t1, EXP...)
	    */
	  int t1 = curTmpNum++, t2 = curTmpNum++;
	  PrintPiglet.println("CALL");
	  PrintPiglet.pBegin();
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
      String callClassName = ((BasicType)n.f0.accept(this, argu)).getName();
      PrintPiglet.println("");
      PrintPiglet.println("HLOAD TEMP " + t2 + " TEMP " + t1 + " 0");
      String callMethodName = n.f2.f0.toString();
      MyMethod curMethod = (MyMethod)argu;
      MyMethod callMethod = curMethod.owner.allClasses.classes.get(callClassName).getMethod_Piglet(callMethodName);
      PrintPiglet.println("HLOAD TEMP " + t2 + " TEMP " + t2 + " " + findMethodPos(callClassName, callMethodName));
      PrintPiglet.pReturn();
      PrintPiglet.println("TEMP " + t2);
      PrintPiglet.pEnd();
      PrintPiglet.println("");
      PrintPiglet.print("(TEMP " + t1 + " ");
      
      n.f4.accept(this, callMethod);
      PrintPiglet.println(")");
      
      BasicType _ret = new BasicType(callMethod.getMethodType().getName(), argu, -1, -1);
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public AllType visit(ExpressionList n, AllType argu) {
	  RealArgInfo curArgInfo = new RealArgInfo();
	  curArgInfo.curArguNum = 1;
	  curArgInfo.refMethod = (MyMethod)argu;
	  if(((MyMethod)argu).paraName.size() >= 20){
		  curArgInfo.over20Argu = true;
	  }
	  else {
		  curArgInfo.over20Argu = false;
	  }
      n.f0.accept(this, argu);
      n.f1.accept(this, curArgInfo);
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public AllType visit(ExpressionRest n, AllType argu) {
	  RealArgInfo curArgInfo = (RealArgInfo)argu;
      if(curArgInfo.over20Argu == true) {
    	  /*
    	   * BEGIN
    	   * 	MOVE TEMP t1 HALLOCATE (((MyMethod)argu).paraName.size() - 18) * 4
    	   * 	HSTORE TEMP t1 0 EXP
    	   * 	HSTORE TEMP t1 4 EXP
    	   * 	...
    	   * RETURN TEMP t1
    	   * END
    	   */
    	  curArgInfo.curArguNum++;
    	  if(curArgInfo.curArguNum == 19) {
    		  curArgInfo.curArguListTmp = curTmpNum++;
    		  PrintPiglet.pBegin();
    		  PrintPiglet.println("MOVE TEMP " + curArgInfo.curArguListTmp + " HALLOCATE " + ((curArgInfo.refMethod.paraName.size() - 18) << 2));
    		  PrintPiglet.print("HSTORE TEMP " + curArgInfo.curArguListTmp + " 0 ");
    		  n.f1.accept(this, argu);
    		  PrintPiglet.println("");
    	  }
    	  else if(curArgInfo.curArguNum > 19) {
    		  PrintPiglet.print("HSTORE TEMP " + curArgInfo.curArguListTmp + " " + ((curArgInfo.curArguNum - 19) << 2) + " ");
    		  n.f1.accept(this, argu);
    		  PrintPiglet.println("");
    	  }
    	  else {
    		  n.f1.accept(this, argu);
    		  PrintPiglet.print(" ");
    	  }
    	  if(curArgInfo.curArguNum == curArgInfo.refMethod.paraName.size()){
    		  PrintPiglet.pReturn();
    		  PrintPiglet.println("TEMP " + curArgInfo.curArguListTmp);
    		  PrintPiglet.pEnd();
    	  }
      }
      else {
    	  n.f1.accept(this, argu);
    	  PrintPiglet.print(" ");
      }    
      return null;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public AllType visit(PrimaryExpression n, AllType argu) {
	  AllType _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public AllType visit(IntegerLiteral n, AllType argu) {
      PrintPiglet.print(n.f0.toString() + " ");
      BasicType _ret=new BasicType("int", argu, n.f0.beginLine, n.f0.beginColumn);
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public AllType visit(TrueLiteral n, AllType argu) {
	  PrintPiglet.print("1 ");
	  BasicType _ret=new BasicType("boolean", argu, n.f0.beginLine, n.f0.beginColumn);
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public AllType visit(FalseLiteral n, AllType argu) {
	  PrintPiglet.print("0 ");
	  BasicType _ret=new BasicType("boolean", argu, n.f0.beginLine, n.f0.beginColumn);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public AllType visit(Identifier n, AllType argu) {
	   //注意使用全局的当前的类和方法
	   String curSym = n.f0.toString();
	   BasicType curVar = null;
	   MyMethod curMethod = nowMethod;
	   curVar = curMethod.findId(curSym);
	   String curVarName = n.f0.toString();
	   MyClass curClass = nowClass;
	   //在局部变量表且有寄存器保存他的值的时候
	   if(curTmpVarList.get(curVarName) != null) {
		   PrintPiglet.print("TEMP " + curTmpVarList.get(curVarName) + " ");
	   }
	   else {
		   int t1 = curTmpNum++;
		   int offset = -1;
		   for(int i = 18; i < curMethod.paraName.size(); i++) {
			   if(curMethod.paraName.get(i).equals(curVarName))
				   offset = (i - 18) << 2;
		   }
		   if(offset != -1) { //当前方法的参数列表超过了19个，若该变量在参数列表的第19个或之后，需要用地址加偏移找到
			   PrintPiglet.pBegin();
			   PrintPiglet.println("HLOAD TEMP " + t1 + " TEMP 19 " + offset);
			   PrintPiglet.pReturn();
			   PrintPiglet.println("TEMP " + t1);
			   PrintPiglet.pEnd();
		   }
		   else { //否则在类的成员变量中，需要用地址加偏移找到
			   PrintPiglet.pBegin();
			   PrintPiglet.println("HLOAD TEMP " + t1 + " TEMP 0 " + findVarPos(curClass.getName(), curVarName));
			   PrintPiglet.pReturn();
			   PrintPiglet.println("TEMP " + t1);
			   PrintPiglet.pEnd();
		   }
	   }
	   return curVar;
   }

   /**
    * f0 -> "this"
    */
   public AllType visit(ThisExpression n, AllType argu) {
	  PrintPiglet.print("TEMP 0 ");
	  MyClass curClass = null;
	  if(argu instanceof MyMethod) {
		  curClass = ((MyMethod)argu).owner;
	  }
	  else if(argu instanceof RealArgList) {
		  curClass = ((RealArgList)argu).getOwner().owner;
	  }
      BasicType _ret=new BasicType(curClass.getName(), curClass, curClass.getRow(), curClass.getRow());
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public AllType visit(ArrayAllocationExpression n, AllType argu) {
	  /*
	   * BEGIN
	   * 	MOVE TEMP t1 EXP
	   * 	MOVE TEMP t2 HALLOCATE TIMES PLUS TEMP t1 1 4
	   * 	HSTORE TEMP t2 0 TEMP t1
	   * 	RETURN TEMP t2
	   * END
	   */
	  int t1 = curTmpNum++, t2 = curTmpNum++;
	  PrintPiglet.pBegin();
	  PrintPiglet.print("MOVE TEMP " + t1 + " ");
      n.f3.accept(this, argu);
      PrintPiglet.println("");
      PrintPiglet.println("MOVE TEMP " + t2 + " HALLOCATE TIMES PLUS TEMP " + t1 + " 1 4");
      PrintPiglet.println("HSTORE TEMP " + t2 + " 0 TEMP " + t1);
      PrintPiglet.pReturn();
      PrintPiglet.println("TEMP " + t2);
      PrintPiglet.pEnd();
      BasicType _ret = new BasicType("int[]", argu, n.f0.beginLine, n.f0.beginColumn);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public AllType visit(AllocationExpression n, AllType argu) {
	   //类的空间由方法组指针和若干变量组成，方法组指针指向所有方法，包括祖先的方法
	   //t1是类的空间首地址，t2是t1的首地址的值，且指向方法组的首地址
	   /*
	    * BEGIN
	    * 	MOVE TEMP t1 HALLOCATE (varlist.size() + 1) * 4
	    * 	MOVE TEMP t2 HALLOCATE methodlist.size() * 4
	    * 	HSTORE TEMP t1 0 TEMP t2
	    * 
	    * 	...
	    * 	HSTORE TEMP t2 4i methodName
	    * 	...
	    *
	    *	RETURN TEMP t1
	    * END
	    */
      String curClassName = n.f1.f0.toString();
      int t1 = curTmpNum++, t2 = curTmpNum++;
      PrintPiglet.pBegin();
      PrintPiglet.println("MOVE TEMP " + t1 + " HALLOCATE " + ((varList.get(curClassName).size() + 1) << 2));
      PrintPiglet.println("MOVE TEMP " + t2 + " HALLOCATE " + (methodList.get(curClassName).size() << 2));
      PrintPiglet.println("HSTORE TEMP " + t1 + " 0 TEMP " + t2);
      for(int i = 0; i < methodList.get(curClassName).size(); i++)
    	  PrintPiglet.println("HSTORE TEMP " + t2 + " " + (i << 2) + " " + methodList.get(curClassName).get(i));
      PrintPiglet.pReturn();
      PrintPiglet.println("TEMP " + t1);
      PrintPiglet.pEnd();
      BasicType _ret = new BasicType(curClassName, argu, n.f1.f0.beginLine, n.f1.f0.beginColumn);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public AllType visit(NotExpression n, AllType argu) {
	  /*
	   * MINUS 1 EXP
	   */
	  PrintPiglet.print("MINUS 1 ");
	  return n.f1.accept(this, argu);
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public AllType visit(BracketExpression n, AllType argu) {
	   return n.f1.accept(this, argu);
   }

}
