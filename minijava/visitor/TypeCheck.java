//
// Generated by JTB 1.3.2
//

package minijava.visitor;
import minijava.syntaxtree.*;

import minijava.typecheck.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class TypeCheck extends GJDepthFirst<AllType,AllType> {

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public AllType visit(Goal n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public AllType visit(MainClass n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      /*
       * 获得主类和main方法
       */
      String curClassName = n.f1.f0.toString();
      MyClass curClass = ((AllClasses)argu).getMyClass(curClassName);
      MyMethod curMethod = curClass.getMethod("main");
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, curMethod);
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, curMethod);
      n.f15.accept(this, curMethod);
      n.f16.accept(this, argu);
      n.f17.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public AllType visit(TypeDeclaration n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public AllType visit(ClassDeclaration n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      /*
       * 获得相关的类
       */
      String curClassName = n.f1.f0.toString();
      MyClass curClass = ((AllClasses)argu).getMyClass(curClassName);
      //如果这是非第一个被重复定义的类，那么不进行后续的类型检查
      if(curClass.getRepeated() == true) return _ret;
      n.f2.accept(this, argu);
      n.f3.accept(this, curClass);
      n.f4.accept(this, curClass);
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public AllType visit(ClassExtendsDeclaration n, AllType argu) {
	  String errorMsg = null;
      AllType _ret=null;
      n.f0.accept(this, argu);
      /*
       * 获得相关的类
       */
      String curClassName = n.f1.f0.toString();
      MyClass curClass = ((AllClasses)argu).getMyClass(curClassName);
      //如果这是非第一个被重复定义的类，那么不进行后续的类型检查
      if(curClass.getRepeated() == true) return _ret;
      curClass.setRepeated();
      
      n.f2.accept(this, argu);
      //n.f3.accept(this, argu);
      /*
       * 检查循环继承
       */
      if(curClass.checkLoop() == 0) {
    	  errorMsg = "cyclic inheritance involving " + curClass.getName();
    	  PrintErrorMsg.addError(errorMsg, curClass.getRow(), curClass.getCol());
    	  return null;
      }
     
      n.f4.accept(this, argu);
      n.f5.accept(this, curClass);
      n.f6.accept(this, curClass);
      n.f7.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public AllType visit(VarDeclaration n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      //n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public AllType visit(MethodDeclaration n, AllType argu) {
	  String errorMsg = null;
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      /*
       * 找到该方法
       */
      String methodName = n.f2.f0.toString();
      MyMethod curMethod = ((MyClass)argu).getMethod(methodName);
      
      //如果这是非第一个被重复定义的方法，那么不进行后续的类型检查
      if(curMethod.getRepeated() == true) return _ret;
      curMethod.setRepeated();
      
      //检查方法重写是否存在错误（方法名一样，且参数列表类型一样，但返回值类型不一样）
      errorMsg = null;
      errorMsg = curMethod.override();
      if(errorMsg != null) {
    	  PrintErrorMsg.addError(errorMsg, curMethod.getRow(), curMethod.getCol());
      }
      
      n.f3.accept(this, argu);
      n.f4.accept(this, curMethod);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, curMethod);
      n.f8.accept(this, curMethod);
      n.f9.accept(this, argu);
      
      /*
       * 检查返回值类型
       */
      AllType retContent = n.f10.accept(this, curMethod);
      if(retContent != null && !curMethod.getMethodType().isSameType((BasicType)retContent)) {
    	  errorMsg = "return incompatible type: expected " + curMethod.getMethodType().getName();
    	  PrintErrorMsg.addError(errorMsg, n.f9.beginLine, n.f9.beginColumn);
      }
      
      
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public AllType visit(FormalParameterList n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public AllType visit(FormalParameter n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      //n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public AllType visit(FormalParameterRest n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public AllType visit(Type n, AllType argu) {
      AllType _ret = null;
      //n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public AllType visit(ArrayType n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public AllType visit(BooleanType n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public AllType visit(IntegerType n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public AllType visit(Statement n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public AllType visit(Block n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public AllType visit(AssignmentStatement n, AllType argu) {
	  String errorMsg = null;
      AllType _ret=null;
      BasicType leftSym = (BasicType)n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      /*
       * 检查左右类型是否匹配
       */
      AllType rightExp = n.f2.accept(this, argu);
      if(leftSym == null || rightExp == null) return _ret;
      if(!leftSym.isSameType((BasicType)rightExp)) {
    	  errorMsg = "assign right Statement incompatible type: expected " + leftSym.getName();
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
      }
      
      
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public AllType visit(ArrayAssignmentStatement n, AllType argu) {
	  /*
	   * 检查数组赋值
	   */
	  String errorMsg = null;
      AllType _ret=null;
      AllType leftSym = n.f0.accept(this, argu);
      /*
       * 检查当前变量是否为数组类型
       */
      if(leftSym != null && !leftSym.getName().equals("int[]")) {
    	  errorMsg = "incompatible types: " + leftSym.getName() + " cannot be converted to int[]";
    	  PrintErrorMsg.addError(errorMsg, n.f0.f0.beginLine, n.f0.f0.beginColumn);
    	  return _ret;
      }
      
      n.f1.accept(this, argu);
      
      AllType subScript = n.f2.accept(this, argu);
      /*
       * 检查数组中括号内下标是否为整数
       */
      if(subScript != null && !subScript.getName().equals("int")) {
    	  errorMsg = "incompatible types: possible lossy conversion from " + subScript.getName() + " to int";
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
      }
      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      /*
       * 检查数组右侧赋值是否为整型
       */
      AllType rightExp = n.f5.accept(this, argu);
      if(rightExp != null && !rightExp.getName().equals("int")) {
    	  errorMsg = "incompatible types: possible lossy conversion from " + rightExp.getName() + " to int";
    	  PrintErrorMsg.addError(errorMsg, n.f4.beginLine, n.f4.beginColumn);
      }
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public AllType visit(IfStatement n, AllType argu) {
	  String errorMsg = null;
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      /*
       * 检查if语句内部表达式是否为布尔型
       */
      AllType ifStat = n.f2.accept(this, argu);
      if(ifStat != null && !ifStat.getName().equals("boolean")) {
    	  errorMsg = "incompatible types: possible lossy conversion from " + ifStat.getName() + " to boolean";
    	  PrintErrorMsg.addError(errorMsg, n.f0.beginLine, n.f0.beginColumn);
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public AllType visit(WhileStatement n, AllType argu) {
	  String errorMsg = null;
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      /*
       * 检查while语句内部表达式是否为布尔型
       */
      AllType whileStat = n.f2.accept(this, argu);
      if(whileStat != null && !whileStat.getName().equals("boolean")) {
    	  errorMsg = "incompatible types: possible lossy conversion from " + whileStat.getName() + " to boolean";
    	  PrintErrorMsg.addError(errorMsg, n.f0.beginLine, n.f0.beginColumn);
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public AllType visit(PrintStatement n, AllType argu) {
	  String errorMsg = null;
      AllType _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      /*
       * 检查System.out.println语句内部表达式是否为布尔型或整型
       */
      AllType printStat = n.f2.accept(this, argu);
      if(printStat != null && !printStat.getName().equals("boolean") && !printStat.getName().equals("int")) {
    	  errorMsg = "incompatible types: possible lossy conversion from " + printStat.getName() + " to boolean or int";
    	  PrintErrorMsg.addError(errorMsg, n.f0.beginLine, n.f0.beginColumn);
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public AllType visit(Expression n, AllType argu) {
      AllType _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(AndExpression n, AllType argu) {
	  String errorMsg = null;
	  AllType _ret = null;
      AllType leftExp = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      AllType rightExp = n.f2.accept(this, argu);
      if(leftExp == null || rightExp == null) return null;
      if(!leftExp.getName().equals("boolean") || !rightExp.getName().equals("boolean")) {
    	  errorMsg = "bad operand types for binary operator &&";
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
      }
      else {
    	  _ret = new BasicType("boolean", (MyMethod)argu, leftExp.getRow(), leftExp.getCol());
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(CompareExpression n, AllType argu) {
	   String errorMsg = null;
	   AllType _ret = null;
	   AllType leftExp = n.f0.accept(this, argu);
	   n.f1.accept(this, argu);
	   AllType rightExp = n.f2.accept(this, argu);
	   if(leftExp == null || rightExp == null) return null;
	   if(!leftExp.getName().equals("int") || !rightExp.getName().equals("int")) {
		   errorMsg = "bad operand types for binary operator <";
		   PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
	   }
	   else {
		   _ret = new BasicType("boolean", (MyMethod)argu, leftExp.getRow(), leftExp.getCol());
	   }
	   return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(PlusExpression n, AllType argu) {
	   String errorMsg = null;
	   AllType _ret = null;
	   AllType leftExp = n.f0.accept(this, argu);
	   n.f1.accept(this, argu);
	   AllType rightExp = n.f2.accept(this, argu);
	   if(leftExp == null || rightExp == null) return null;
	   if(!leftExp.getName().equals("int") || !rightExp.getName().equals("int")) {
		   errorMsg = "bad operand types for binary operator +";
		   PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
	   }
	   else {
		   _ret = new BasicType("int", (MyMethod)argu, leftExp.getRow(), leftExp.getCol());
	   }
	   return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(MinusExpression n, AllType argu) {
	   String errorMsg = null;
	   AllType _ret = null;
	   AllType leftExp = n.f0.accept(this, argu);
	   n.f1.accept(this, argu);
	   AllType rightExp = n.f2.accept(this, argu);
	   if(leftExp == null || rightExp == null) return null;
	   if(!leftExp.getName().equals("int") || !rightExp.getName().equals("int")) {
		   errorMsg = "bad operand types for binary operator -";
		   PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
	   }
	   else {
		   _ret = new BasicType("int", argu, leftExp.getRow(), leftExp.getCol());
	   }
	   return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public AllType visit(TimesExpression n, AllType argu) {
	   String errorMsg = null;
	   AllType _ret = null;
	   AllType leftExp = n.f0.accept(this, argu);
	   n.f1.accept(this, argu);
	   AllType rightExp = n.f2.accept(this, argu);
	   if(leftExp == null || rightExp == null) return null;
	   if(!leftExp.getName().equals("int") || !rightExp.getName().equals("int")) {
		   errorMsg = "bad operand types for binary operator *";
		   PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
	   }
	   else {
		   _ret = new BasicType("int", (MyMethod)argu, leftExp.getRow(), leftExp.getCol());
	   }
	   return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public AllType visit(ArrayLookup n, AllType argu) {
	   /*
	    * 数组取值
	    */
	  String errorMsg = null;
      AllType _ret=null;
      AllType curArray = n.f0.accept(this, argu);
      /*
       * 检查当前符号是否为数组类型
       */
      if(curArray != null && !curArray.getName().equals("int[]")) {
    	  errorMsg = "incompatible types: " + curArray.getName() + " cannot be converted to int[]";
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
    	  return _ret;
      }
      n.f1.accept(this, argu);
      AllType subScript = n.f2.accept(this, argu);
      /*
       * 检查下标是否为整型
       */
      if(subScript != null && !subScript.getName().equals("int")) {
    	  errorMsg = "incompatible types: " + subScript.getName() + " cannot be converted to int[]";
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
    	  return _ret;
      }
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public AllType visit(ArrayLength n, AllType argu) {
	  String errorMsg;
      AllType _ret=null;
      AllType curArray = n.f0.accept(this, argu);
      /*
       * 检查当前符号是否为数组类型
       */
      if(!curArray.getName().equals("int[]")) {
    	  errorMsg = "incompatible types: " + curArray.getName() + " cannot be converted to int[]";
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
    	  return _ret;
      }
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public AllType visit(MessageSend n, AllType argu) {
	  String errorMsg = null;
      BasicType leftExp = (BasicType)n.f0.accept(this, argu);
      //先判断左边表达式是不是类的类型
      if(leftExp == null) return null;
      if(leftExp.isSimpleType()) {
    	  errorMsg = leftExp.getName() + " cannot be dereferenced";
    	  PrintErrorMsg.addError(errorMsg, n.f1.beginLine, n.f1.beginColumn);
    	  return null;
      }
      //获得那个类
      MyClass curClass = leftExp.refWhichClass();
      n.f1.accept(this, argu);
      //获得方法名
      String curMethodName = n.f2.f0.toString();
      
      n.f3.accept(this, argu);
      RealArgList curArgu = (RealArgList)n.f4.accept(this, argu);
      //根据方法名和参数表类型寻找方法
      if(curClass == null) {
    	  return null;
      }
      MyMethod curMethod = curClass.getMethod(curMethodName, curArgu);
      if(curMethod == null) {
    	  errorMsg = "cannot find symbol: " + curMethodName; 
    	  PrintErrorMsg.addError(errorMsg, n.f2.f0.beginLine, n.f2.f0.beginColumn);
    	  return null;
      }
      n.f5.accept(this, argu);
      BasicType _ret = new BasicType(curMethod.getMethodType().getName(), argu, curMethod.getRow(), curMethod.getCol());
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public AllType visit(ExpressionList n, AllType argu) {
	  AllType curExp = n.f0.accept(this, argu);
	  if(curExp == null) return null;
      RealArgList _ret = new RealArgList();
      _ret.setOwner((MyMethod)argu);
      _ret.insertArg((BasicType)curExp);
      n.f1.accept(this, _ret);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public AllType visit(ExpressionRest n, AllType argu) {
      AllType _ret=null;
      AllType curExp = n.f1.accept(this, argu);
      if(curExp == null) return null;
      ((RealArgList)argu).insertArg((BasicType)curExp);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public AllType visit(PrimaryExpression n, AllType argu) {
      AllType _ret=n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public AllType visit(IntegerLiteral n, AllType argu) {
      BasicType _ret=new BasicType("int", argu, n.f0.beginLine, n.f0.beginColumn);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public AllType visit(TrueLiteral n, AllType argu) {
	  BasicType _ret=new BasicType("boolean", argu, n.f0.beginLine, n.f0.beginColumn);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public AllType visit(FalseLiteral n, AllType argu) {
	  BasicType _ret = new BasicType("boolean", argu, n.f0.beginLine, n.f0.beginColumn);
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public AllType visit(Identifier n, AllType argu) {
	  String errorMsg;
      String curSym = n.f0.toString();
      BasicType curVar = null;
	  //表达式中的标识符需要到这里来解析
	  if(argu instanceof MyMethod) {
		  MyMethod curMethod = (MyMethod)argu;
		  curVar = curMethod.findId(curSym);
	  }
	  //实参表中的标识符来这里解析
	  else if(argu instanceof RealArgList) {
		  MyMethod curMethod = ((RealArgList)argu).getOwner();
		  curVar = curMethod.findId(curSym);
	  }
	  if(curVar == null) {
		  errorMsg = "cannot find symbol: " + curSym; 
		  PrintErrorMsg.addError(errorMsg, n.f0.beginLine, n.f0.beginColumn);
	  }
	  return curVar;
   }

   /**
    * f0 -> "this"
    */
   public AllType visit(ThisExpression n, AllType argu) {
	  MyClass curClass = null;
	  if(argu instanceof MyMethod) {
		  curClass = ((MyMethod)argu).owner;
	  }
	  else if(argu instanceof RealArgList) {
		  curClass = ((RealArgList)argu).getOwner().owner;
	  }
      BasicType _ret=new BasicType(curClass.getName(), curClass, curClass.getRow(), curClass.getRow());
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public AllType visit(ArrayAllocationExpression n, AllType argu) {
	  String errorMsg;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      AllType lenExp = n.f3.accept(this, argu);
      if(lenExp != null && !lenExp.getName().equals("int")) {
    	  errorMsg = "incompatible types: possible lossy conversion from " + lenExp.getName() + " to int";
    	  PrintErrorMsg.addError(errorMsg, lenExp.getRow(), lenExp.getCol());
    	  return null;
      }
      BasicType _ret = new BasicType("int[]", argu, n.f0.beginLine, n.f0.beginColumn);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public AllType visit(AllocationExpression n, AllType argu) {
      BasicType _ret = null;
      n.f0.accept(this, argu);
      String curClassName = n.f1.f0.toString();
      _ret = new BasicType(curClassName, argu, n.f1.f0.beginLine, n.f1.f0.beginColumn);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public AllType visit(NotExpression n, AllType argu) {
      AllType _ret=null;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public AllType visit(BracketExpression n, AllType argu) {
      AllType _ret;
      n.f0.accept(this, argu);
      _ret = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

}
